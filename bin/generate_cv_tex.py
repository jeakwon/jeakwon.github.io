#!/usr/bin/env python3
"""
Generate cv.tex from _data/cv.yml and _bibliography/papers.bib.
Single Source of Truth: edit YAML/BibTeX, get PDF automatically.

Style: Minimalist academic CV inspired by Pascal Michaillat's template.
       Source Serif Pro, gray accents, clean typography.

WARNING: This file generates cv.tex — do NOT edit cv.tex manually.
"""

import re
import sys
from pathlib import Path
from collections import defaultdict
from datetime import datetime

try:
    import yaml
except ImportError:
    sys.exit("pyyaml required: pip install pyyaml")

try:
    import bibtexparser
except ImportError:
    sys.exit("bibtexparser required: pip install bibtexparser")

# --- Paths (relative to repo root) ---
REPO_ROOT = Path(__file__).resolve().parent.parent
CV_YML = REPO_ROOT / "_data" / "cv.yml"
PAPERS_BIB = REPO_ROOT / "_bibliography" / "papers.bib"
OUTPUT_TEX = REPO_ROOT / "cv.tex"

SELF_LAST_NAME = "Kwon"
WEBSITE_URL = "https://jeakwon.github.io/homepage-v2"
EMAIL = "onlytojay@gmail.com"
SCHOLAR_URL = "https://scholar.google.com/citations?user=6I0mg_EAAAAJ"

# --- LaTeX preamble (Michaillat-style minimalist) ---
PREAMBLE = r"""% Auto-generated by bin/generate_cv_tex.py — DO NOT EDIT MANUALLY
\documentclass[a4paper,10pt]{article}

% ---- Fonts ----
\input{glyphtounicode}
\pdfgentounicode=1
\usepackage[T1]{fontenc}
\usepackage{sourceserifpro}
\DeclareRobustCommand{\sbseries}{\fontseries{sb}\selectfont}
\DeclareTextFontCommand{\textsb}{\sbseries}
\usepackage{sourcecodepro}
\usepackage[hyphens]{url}

% ---- Layout ----
\usepackage[top=0.9in, bottom=1.1in, left=1.2in, right=1.2in, footskip=0.7in]{geometry}
\usepackage{setspace}
\setstretch{1.1}
\usepackage{microtype}

% ---- Colors ----
\usepackage[x11names]{xcolor}

% ---- Header & Footer ----
\usepackage{fancyhdr}
\pagestyle{fancy}
\renewcommand{\headrule}{}
\fancyhf{}
\newcommand{\grayfoot}[2]{\fancyfoot[#1]{\footnotesize\textcolor{gray}{#2}}}

% ---- Section formatting ----
\usepackage{titlesec}
\titleformat*{\section}{\centering\Huge\scshape}
\titleformat*{\subsection}{\vskip-3mm\sbseries\scshape\color{gray}}

% ---- Lists ----
\usepackage{enumitem}
\usepackage[leftmargin=2em]{etaremune}
\setlist[itemize,1]{leftmargin=2em,label=\color{gray}{\textendash}}
\setlist[enumerate,1]{leftmargin=2em}
\renewcommand{\labelenumi}{\color{gray}\theenumi.}

% ---- Hyperlinks ----
\usepackage[hidelinks, hypertexnames=false, pdfpagemode=UseNone, pdfdisplaydoctitle=true]{hyperref}

% ---- CV commands ----
\newcommand{\name}[1]{\section*{#1}}
\newcommand{\sep}{{\color{gray}\,\textbullet\,\,}}
\newcommand{\hsep}{\noindent\textcolor{gray}{\rule{\textwidth}{0.7pt}}}
\newcommand{\block}[1]{\begin{samepage}\hsep\subsection*{{#1}}\end{samepage}}
\newcommand{\with}[1]{\,(with #1)}
"""


def escape_latex(text: str) -> str:
    """Escape special LaTeX characters in plain text."""
    if not text:
        return ""
    text = str(text)
    text = text.replace("\\", "\\textbackslash{}")
    for char in "&%$#_{}":
        text = text.replace(char, f"\\{char}")
    text = text.replace("~", "\\textasciitilde{}")
    text = text.replace("^", "\\textasciicircum{}")
    return text


def load_cv_data() -> list:
    with open(CV_YML, "r", encoding="utf-8") as f:
        return yaml.safe_load(f)


def load_publications() -> list:
    with open(PAPERS_BIB, "r", encoding="utf-8") as f:
        content = f.read()
    content = re.sub(r"^---\s*\n---\s*\n", "", content)
    parser = bibtexparser.bparser.BibTexParser(common_strings=True)
    bib_db = bibtexparser.loads(content, parser=parser)
    return bib_db.entries


def format_author_short(author_string: str) -> str:
    """Convert BibTeX authors to short form: 'J. Kwon, L. F. Vecchietti, ...'
    Self (Kwon) is bolded."""
    authors = [a.strip() for a in author_string.split(" and ")]
    formatted = []
    for author in authors:
        if author.lower() == "others":
            formatted.append("et al.")
            continue

        # Strip markers
        clean = author.replace("*", "").replace("\u2020", "")

        # Parse "Last, First"
        if "," in clean:
            parts = clean.split(",", 1)
            last = parts[0].strip()
            first = parts[1].strip() if len(parts) > 1 else ""
        else:
            words = clean.strip().split()
            if len(words) > 1:
                last = words[-1]
                first = " ".join(words[:-1])
            else:
                last = clean.strip()
                first = ""

        # Abbreviate first names
        initials = ". ".join(w[0] for w in first.split() if w) + "." if first else ""
        short = f"{initials} {escape_latex(last)}".strip()

        if SELF_LAST_NAME in last:
            short = f"\\textbf{{{short}}}"

        formatted.append(short)

    return ", ".join(formatted)


def render_publications(entries: list) -> str:
    """Render publications as reverse-numbered list (etaremune)."""
    sorted_entries = sorted(
        entries, key=lambda e: int(e.get("year", "0")), reverse=True
    )

    lines = ["\\block{publications}", "", "\\begin{etaremune}"]

    for entry in sorted_entries:
        authors = format_author_short(entry.get("author", ""))
        title = entry.get("title", "")
        # Preserve $...$ math mode, strip BibTeX braces, then escape
        math_spans = re.findall(r'\$[^$]+\$', title)
        placeholders = {}
        for i, m in enumerate(math_spans):
            ph = f"MTHPHLDR{i}ZZ"
            placeholders[ph] = m
            title = title.replace(m, ph, 1)
        title = title.replace("{", "").replace("}", "")
        title = escape_latex(title)
        for ph, m in placeholders.items():
            title = title.replace(ph, m)
        venue = entry.get("journal", "") or entry.get("booktitle", "")
        venue = escape_latex(venue)
        year = entry.get("year", "")

        lines.append(f"\\item {title} \\with{{{authors}}}\\\\")
        lines.append(f"\\textit{{{venue}}} \\sep {year}")

    lines.append("\\end{etaremune}")
    return "\n".join(lines)


def render_cv_section_items(section: dict) -> str:
    r"""Render a time_table section using Michaillat \sep style."""
    title = section.get("title", "").lower()
    lines = [f"\\block{{{title}}}", "", "\\begin{itemize}"]

    for item in section.get("contents", []):
        year = str(item.get("year", ""))
        item_title = item.get("title", "")
        institution = item.get("institution", "")

        if item_title and institution:
            parts = [escape_latex(institution), escape_latex(item_title), escape_latex(year)]
            line = " \\sep ".join(parts)

            descs = item.get("description", [])
            if descs:
                desc_lines = []
                for d in descs:
                    if isinstance(d, str):
                        desc_lines.append(escape_latex(d))
                line += "\\\\\n" + "\\\\".join(desc_lines) if desc_lines else ""

            lines.append(f"\\item {line}")
        elif "items" in item:
            for award in item["items"]:
                lines.append(f"\\item {escape_latex(award)} \\sep {escape_latex(year)}")

    lines.append("\\end{itemize}")
    return "\n".join(lines)


def render_list_section(section: dict) -> str:
    """Render a list section."""
    title = section.get("title", "").lower()
    lines = [f"\\block{{{title}}}", "", "\\begin{itemize}"]
    for item in section.get("contents", []):
        lines.append(f"\\item {escape_latex(str(item))}")
    lines.append("\\end{itemize}")
    return "\n".join(lines)


def render_nested_list(section: dict) -> str:
    """Render a nested list section."""
    title = section.get("title", "").lower()
    lines = [f"\\block{{{title}}}", "", "\\begin{itemize}"]
    for group in section.get("contents", []):
        items_str = ", ".join(escape_latex(i) for i in group.get("items", []))
        lines.append(f"\\item {escape_latex(group.get('title', ''))} \\sep {items_str}")
    lines.append("\\end{itemize}")
    return "\n".join(lines)


def generate_cv_tex():
    cv_data = load_cv_data()
    publications = load_publications()

    # Extract name from General Information
    name = "jea kwon"
    for section in cv_data:
        if section.get("title") == "General Information":
            for item in section.get("contents", []):
                if item.get("name") == "Name":
                    name = item["value"].lower()
            break

    # Footer
    now = datetime.now()
    date_str = now.strftime("%B %Y")

    footer = (
        f"\\hypersetup{{pdftitle={{{escape_latex(name.title())}'s CV}}}}\n"
        f"\\grayfoot{{C}}{{\\url{{{EMAIL}}}}}\n"
        f"\\grayfoot{{L}}{{\\url{{{WEBSITE_URL}}}}}\n"
        f"\\grayfoot{{R}}{{{date_str}}}\n"
    )

    # Build document
    parts = [PREAMBLE, footer, "\\begin{document}", "", f"\\name{{{name}}}"]

    # Render each cv.yml section
    for section in cv_data:
        st = section.get("type", "")
        title = section.get("title", "")
        if title == "General Information":
            continue
        if st == "time_table":
            parts.append(render_cv_section_items(section))
        elif st == "list":
            parts.append(render_list_section(section))
        elif st == "nested_list":
            parts.append(render_nested_list(section))

    # Publications (from papers.bib)
    parts.append(render_publications(publications))

    parts.append("\n\\end{document}\n")

    full_tex = "\n\n".join(parts)

    with open(OUTPUT_TEX, "w", encoding="utf-8") as f:
        f.write(full_tex)
    print(f"Generated {OUTPUT_TEX}")


if __name__ == "__main__":
    generate_cv_tex()
